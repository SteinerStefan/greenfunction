%		\begin{shadedSmaller}
%		 was das Ziel war(Was man sehen sollte) 
%		 
%		 wie wir vorgegangen sind "Drehbuch"
%		 
%		 wieso wir so vorgegangen sind
%		 
%		 was die Schwierigkeiten waren 
%		\end{shadedSmaller}

\section{Visualisierung}
	
	\subsection{Prinzip}
			
		Ziel der Visualisierung ist, die einzelnen Schritte einer Berechnung mit der Greenschen Funktion zu zeigen. Dabei soll die Überlagerung der Werte, das Superpositionsprinzip, anschaulich dargestellt werden.
		
		
		Würden wir jeweils alle Punkte einzeln berechnen und sie dann Schrittweise addieren, müssten wir diese Schritte schlussendlich noch Visuell darstellen. Der Aufwand hierfür ist aber beträchtlich.
		Da die Darstellung im Vordergrund steht, ist das Verfahren zur Berechnung irrelevant für das Endergebnis. Um die Rechnung zu beschleunigen, haben wir uns für einen anderen Algorithmus entschieden, welcher uns erlaubt so viele Punkte wie nötig miteinander zu lösen. Im nächsten Kapitel wird darauf genauer eingegangen.
		
		Wir werden dementsprechend immer das Gleiche Problem lösen mit jeweils zusätzlichen Punkten. Jeder dieser Schritte hat ein Bild mit den Vorherigen plus den neuen Punkten zu folge. Zusammengestellt ergeben diese Bilder eine anschauliche Visualisierung der Greenschen Funktion.
	
	
	\subsection{Darstellungsmöglichkeiten}
	
		Welche Punkte wir jeweils im nächsten Schritt wählen ist noch offen. Man könnte beispielsweise die Fläche $f$ von oben links bis unten rechts durchgehen und immer ein oder mehrere Punkte dazu nehmen. Es ist auch vorstellbar diese Punkte zufällig auszuwählen, bis alle Punkte berechnet wurden. Der Nachteil dieser Verfahren ist, dass sie nicht viel weniger aufwändig sind, wie das Verfahren, welches alle Punkte einzeln berechnet. Wenn beispielsweise eine Fläche bzw. Bild mit der Grösse $500 \times 500$ berechnet werden soll, muss das Problem 250\,000 mal vollständig gelöst werden. Es wären auch 250\,000 Bilder vorhanden, eine Datenflut, die unser Auge wohl kaum bewältigen kann. Es ist fraglich, wie sinnvoll eine solche Visualisierung ist.
		
		Um das zu verhindern, haben wir uns entschieden in der Mitte einer solchen Fläche zu beginnen und dann Schrittweise, Ring für Ring, nach aussen zugehen.
		
				\[
					f=\left(
					\begin{array}{ccccc}
					    f_{11}& f_{12}& f_{13}& f_{14}& f_{15}\\
						f_{21}& f_{22}& f_{23}& f_{24}& f_{25}\\
						f_{31}& f_{32}& \red{f_{33}}& f_{34}& f_{35}\\
						f_{41}& f_{42}& f_{43}& f_{44}& f_{45}\\
						f_{51}& f_{52}& f_{53}& f_{54}& f_{55}\\
					\end{array}
					\right) \Rightarrow
					\left(
					\begin{array}{ccccc}
					    f_{11}& f_{12}& f_{13}& f_{14}& f_{15}\\
						f_{21}& \red{f_{22}}& \red{f_{23}}& \red{f_{24}}& f_{25}\\
						f_{31}& \red{f_{32}}& \red{f_{33}}& \red{f_{34}}& f_{35}\\
						f_{41}& \red{f_{42}}& \red{f_{43}}& \red{f_{44}}& f_{45}\\
						f_{51}& f_{52}& f_{53}& f_{54}& f_{55}\\
					\end{array}\right)
					\Rightarrow
					\left(\red{
					\begin{array}{ccccc}
					    f_{11}& f_{12}& f_{13}& f_{14}& f_{15}\\
						f_{21}& f_{22}& f_{23}& f_{24}& f_{25}\\
						f_{31}& f_{32}& f_{33}& f_{34}& f_{35}\\
						f_{41}& f_{42}& f_{43}& f_{44}& f_{45}\\
						f_{51}& f_{52}& f_{53}& f_{54}& f_{55}\\
					\end{array}}
					\right)
					\]
		
		In jedem dieser drei Schritte werden nur die roten Punkte in die Berechnung berücksichtigt, die anderen werden gleich Null gesetzt. Jeder Schritt wir vollständig gelösst, bis der maximale Fehler eine Grenze unterschreitet.
	
	\subsection{Technische Umsetzung}
	
		Vor jeder dieser Berechnungen wird eine Matrix, die die Fläche $f$ repräsentiert, so manipuliert, dass die äusseren Ringe gleich Null gesetzt werden. Danach wird die Berechnung, die in jedem Schritt identisch ist, durchgeführt.
		
		Wir speichern die erhaltene Matrix in einem .csv File mit einer Genauigkeit von vier Nachkommastellen ab, was für eine Visualisierung genügt. Anfangs benutzten wir MATLAB um aus dem .csv-File eine anständige Visualisierung zu erhalten. Der Aufwand war gering und die Resultate waren schnell kontrollierbar.
		
		\lstinputlisting{./csvToMatrixAndPlot.m}
		
		Um das zu automatisieren benutzen wir später Gnuplot, welches sich mit C-Code ohne Probleme ansprechen lässt und uns die Bilder automatisch mit dem vorgegebenen Einstellungen erstellt.
		
		Gnuplot ist ein Kommandozeilen basiertes OpenSource Tool, das aber auch mit GUI erhältlich ist. Über eine Pipe ist es möglich alle Einstellungen vorzunehmen. Dadurch kann aus einer .csv Datei ein Bild im .png Format generiert werden.
		
		\lstinputlisting{./gnuplot.c}
	
	\subsection{Generieren der Bilder}
	
		Die Bilder werden nachdem alle Einzelschritte berechnet wurden, aus den Dateien wiederum parallelisiert in einer \verb|for|-Schleife zu .png Bilddateien verarbeitet. Die Skalierung der $z$-Achse wird direkt aus den Daten des letzten Schrittes berechnet, was uns eine optimale Darstellung garantiert. 
		
		Wir haben jeweils zwei verschiedene Ansichten erstellt: Eine normal Ansicht, d.h ein 3D-Plot wie er z.B. in \fref{fig:201_1} zusehen ist und eine Ansicht von oben mit Höhenlinien. Aus den Bilddateien wird am Schluss optional noch ein Video erstellt.
		