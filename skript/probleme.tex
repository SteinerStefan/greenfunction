\section{Probleme}
	\subsection{Konvergenz}
	
		Wir haben anfangs den HSR-Schriftzug als FITS-File in eine Matrix 
		eingelesen und diesen als Vektor $f$ abgespeichert. Der maximale Wert des Lösungsvektors $u$ betrug anfangs nur 255, stieg nach einigen hundert Iterationen auf über 3000 an und die Funktion nahm die Form eines Haufens an. Wir hatten mit einem anderem Resultat gerechnet und überprüften unseren Algorithmus. Wir entdeckten keinen Fehler in unserem Algorithmus und konnten die Werte mit MATLAB verifizieren. Die nächste Frage war, ob der Gauss-Seidel Algorithmus konvergiert. Wir berechneten den Spektralradius der Matrix $A$ gemäss Definition\;5.1 aus dem Skript HPC\cite{mueller:hpcseminar}:
	
		\begin{eqnarray}
			A = M+N\\
			\varrho(M^{-1}N)<1
		\end{eqnarray}
		
		Die Grösse der Matrix $A$ nimmt mit $n^4$ zu, weshalb die Berechnung der Spektralradien mit MATLAB sehr schnell rechenaufwändig wird. Darum haben wir nur Spektralradien mit kleinem $n$ berechnet.
		
		\begin{table}[h]
			\begin{tabular}{cc}
				n & Specktralradius $\varrho$\\\midrule
				5 & 0.7500\\
				10 & 0.92063\\
				15 & 0.96194\\
				20 & 0.97779\\
				25 & 0.98547\\
				40 & 0.99414
			\end{tabular}
			\centering
			\caption{Spaktralradien der Matrix $A$ für eine Matrix $f$ mit der Grösse $n\times n$}
		\end{table}
	
		Einerseits sind alle Spaktralradien kleiner Eins, was gut ist, andererseits sind sie sehr nahe bei Eins, was erklärt wieso unser Algorithmus so langsam konvergiert.
		
		Wir hatten später Erfolge, wenn wir die Anfangswerte des Vektors $f$ klein wählten $(f_{ij}<1)$. So waren die Fehler von Anfang an kleiner und wir bekamen brauchbare Werte.
	
	\subsection{Datenflut}
	
		Bei Platten mit feiner Diskreditierung mussten wir darauf achten, dass wir nicht zu viele Daten abspeichern. Wir mussten das Programm so umschreiben, dass wir einstellen konnten wie viele Bilder wir schlussendlich wollten. Anhand von diesem Einstellungen wurde nur die benötigten .csv und .png Dateien abgespeichert. Das Programm wurde dadurch automatisch auch gleich viel schneller. 
		
		\begin{shadedSmaller}
			Als Beispiel:
			
			Wir wollen eine Platte mit  $40 \times 40$ Werten berechnen. Um die Konvergenz beobachten zu können, speichern wir nach jeder Iteration die Werte in eine .csv Datei ab. Es sind etwa 3000 bis 4000 Iterationen nötig bis sich die Werte nicht mehr verändern. Das ist alles ohne Problem möglich.
			
			Wir wollen mehr, eine Platte mit $500 \times 500$ Werten. Um hier eine Konvergenz zu beobachten, sind etwa 160\,000 bis 180\,000 Iterationen nötig, wie wir später herausgefunden haben. Das Ganze ist natürlich stark vom Ausgangsbild abhängig.

			Eine .csv Datei ist dann etwa 1.8\,MB gross, d.h. wir wollen ca. 300\,GB abspeichern. Dies ist möglich sofern genügen Platz vorhanden ist. Das eigentliche  Problem ist aber, dass das Programm nur noch mit Daten speichern beschäftigt ist und kaum noch Zeit zum Rechnen hat.	
		\end{shadedSmaller}

	
	\subsection{geeigneter Vektor $f$ finden}\label{sec:geeignetesF}
	
	
		Ein ganz anderes Problem war, ein geeignetes Bild für die Platte zu finden. Es sollte die Überlagerung der Werte gut zeigen. Wir versuchten verschiedene Muster, von einem Schriftzug, einzelne Buchstaben bis zu einzelnen Punkten. Bewährt hat sich eine Spirale. Da wir von innen nach aussen gehen, kommen immer wieder neue Werte an verschiedenen Seiten hinzu. Da schlussendlich nur eine geringe Anzahl Punkte vorhanden sind, wirkt die Visualisierung nicht überladen und ist übersichtlich.