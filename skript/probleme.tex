\section{Probleme}
	\subsection{Konvergenz}
	
		Die Fläche $f$ kann alle möglichen Werte als Anfangsbedingung haben. Wir haben anfangs den  HSR-Schriftzug als FITS-File in eine Matrix 
		eingelesen. Der maximale Wert des $x$ Vektors betrug anfangs nur 255,
		stieg nach einigen hundert Iterationen auf über 3000 an und die Funktion nahm die Form eines Haufens an. Wir hatten mit einem anderem Resultat gerechnet und überprüften unseren Algorithmus. Wir entdeckten keinen Fehler in unserem Algorithmus und konnten die Werte mit MATLAB verifizieren. Die nächste Frage war, ob der Gauss-Seidel konvergiert. Wir berechneten den Spektralradius der Matrix $A$ gemäss Definition\;5.1 aus dem Skript HPC\cite{mueller:hpcseminar}:
	
		\begin{eqnarray}
			A = M+N\\
			\varrho(M^{-1}N)<1
		\end{eqnarray}
		
		Da die Berechnung schnell sehr rechenaufwendig wird, man beachte, dass die Grösse der Matrix $A$ mit $n^4$ zunimmt, haben wir Matrizen mit kleinem $n$ berechnet. 	
		
		\begin{table}[h]
			\begin{tabular}{cc}
				n & Specktralradius $\varrho$\\\midrule
				5 & 0.7500\\
				10 & 0.92063\\
				15 & 0.96194\\
				20 & 0.97779\\
				25 & 0.98547\\
				40 & 0.99414
			\end{tabular}
			\centering
			\caption{Spaktralradien der Matrix $A$ für eine Matrix $f$ mit der Grösse $n\times n$}
		\end{table}
	
		Einerseits sind alle Werte kleiner Eins, was gut ist, andererseits sind die Werte sehr nahe bei Eins, was erklärt wieso unser Algorithmus so langsam konvergiert.
		
		Wir hatten später Erfolge, wenn wir die Anfangswert der Matrix $f$ klein wählten $(f_{ij}<1)$. So waren die Fehler von Anfang an kleiner und wir bekamen brauchbare Werte.
	
	\subsection{Datenflut}
	
		Bei grösseren Matrizen mussten wir darauf achten, dass wir nicht zu viele Daten abspeichern. Wir mussten das Programm so umschreiben, dass wir einstellen konnten wie viele Bilder wir schlussendlich wollten. Anhand von diesem Einstellungen wurde nur die benötigten .csv und .png Dateien abgespeichert. Das Programm wurde dadurch automatisch auch gleich viel schneller. 
		
		\begin{shadedSmaller}
			Als Beispiel:
			
			Wir wollen eine $40 \times 40$ Fläche berechnen. Um die Konvergenz beobachten zu können, speichern wir nach jeder Iteration die Werte in eine .csv Datei ab. Es sind etwa 3000 bis 4000 Iterationen nötig bis sich die Werte nicht mehr verändern. Alles ohne Problem möglich.
			
			Wir wollen mehr, eine Fläche mit $500 \times 500$ Punkten. Um hier eine Konvergenz zu beobachten sind, wie wir später herausgefunden haben, etwa 160\,000 bis 180\,000 Iterationen nötig. Das Ganze ist natürlich stark vom Ausgangsbild abhängig.

			Eine .csv Datei ist dann etwa 1.8\,MB gross, d.h. wir wollen ca. 300\,GB abspeichern. Dies ist möglich sofern genügen Platz vorhanden ist. Das eigentliche  Problem ist aber, dass das Programm nur noch mit Daten speichern beschäftigt ist und kaum noch Zeit zum Rechnen hat.	
		\end{shadedSmaller}

	
	\subsection{geeignete Fläche $f$ finden}\label{sec:geeignetesF}
	
	
		Ein ganz anderes Problem war, ein geeignetes Bild für die Fläche $f$ zu finden. Es sollte die Überlagerung der Werte gut zeigen. Wir versuchten verschiedene Muster, von einem Schriftzug, einzelne Buchstaben bis zu einzelnen Punkten. Bewährt hat sich eine Spirale. Da wir von innen nach aussen gehen, kommen immer wieder neue Punkte auf verschiedenen Seiten hinzu. Da schlussendlich nur eine geringe Anzahl Punkte vorhanden sind, wirkt die Visualisierung nicht überladen und ist übersichtlich.